{"$message_type":"diagnostic","message":"unresolved import `typos::tokens::TokenKind`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/spellcheck.rs","byte_start":62,"byte_end":71,"line_start":2,"line_end":2,"column_start":32,"column_end":41,"is_primary":true,"text":[{"text":"use typos::tokens::{Tokenizer, TokenKind};","highlight_start":32,"highlight_end":41}],"label":"no `TokenKind` in `tokens`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0432]\u001b[0m\u001b[1m: unresolved import `typos::tokens::TokenKind`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/spellcheck.rs:2:32\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m2\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use typos::tokens::{Tokenizer, TokenKind};\n  \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mno `TokenKind` in `tokens`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected a type, found a trait","code":{"code":"E0782","explanation":"Trait objects must include the `dyn` keyword.\n\nErroneous code example:\n\n```edition2021,compile_fail,E0782\ntrait Foo {}\nfn test(arg: Box<Foo>) {} // error!\n```\n\nTrait objects are a way to call methods on types that are not known until\nruntime but conform to some trait.\n\nTrait objects should be formed with `Box<dyn Foo>`, but in the code above\n`dyn` is left off.\n\nThis makes it harder to see that `arg` is a trait object and not a\nsimply a heap allocated type called `Foo`.\n\nTo fix this issue, add `dyn` before the trait name.\n\n```edition2021\ntrait Foo {}\nfn test(arg: Box<dyn Foo>) {} // ok!\n```\n\nThis used to be allowed before edition 2021, but is now an error.\n"},"level":"error","spans":[{"file_name":"src/spellcheck.rs","byte_start":143,"byte_end":160,"line_start":6,"line_end":6,"column_start":17,"column_end":34,"is_primary":true,"text":[{"text":"    dictionary: typos::Dictionary,","highlight_start":17,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can add the `dyn` keyword if you want a trait object","code":null,"level":"help","spans":[{"file_name":"src/spellcheck.rs","byte_start":143,"byte_end":143,"line_start":6,"line_end":6,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"    dictionary: typos::Dictionary,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"dyn ","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0782]\u001b[0m\u001b[1m: expected a type, found a trait\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/spellcheck.rs:6:17\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m6\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     dictionary: typos::Dictionary,\n  \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you can add the `dyn` keyword if you want a trait object\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m6\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    dictionary: \u001b[92mdyn \u001b[0mtypos::Dictionary,\n  \u001b[1m\u001b[94m|\u001b[0m                 \u001b[92m+++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected a type, found a trait","code":{"code":"E0782","explanation":"Trait objects must include the `dyn` keyword.\n\nErroneous code example:\n\n```edition2021,compile_fail,E0782\ntrait Foo {}\nfn test(arg: Box<Foo>) {} // error!\n```\n\nTrait objects are a way to call methods on types that are not known until\nruntime but conform to some trait.\n\nTrait objects should be formed with `Box<dyn Foo>`, but in the code above\n`dyn` is left off.\n\nThis makes it harder to see that `arg` is a trait object and not a\nsimply a heap allocated type called `Foo`.\n\nTo fix this issue, add `dyn` before the trait name.\n\n```edition2021\ntrait Foo {}\nfn test(arg: Box<dyn Foo>) {} // ok!\n```\n\nThis used to be allowed before edition 2021, but is now an error.\n"},"level":"error","spans":[{"file_name":"src/spellcheck.rs","byte_start":292,"byte_end":309,"line_start":13,"line_end":13,"column_start":25,"column_end":42,"is_primary":true,"text":[{"text":"            dictionary: typos::Dictionary::new(),","highlight_start":25,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can add the `dyn` keyword if you want a trait object","code":null,"level":"help","spans":[{"file_name":"src/spellcheck.rs","byte_start":292,"byte_end":292,"line_start":13,"line_end":13,"column_start":25,"column_end":25,"is_primary":true,"text":[{"text":"            dictionary: typos::Dictionary::new(),","highlight_start":25,"highlight_end":25}],"label":null,"suggested_replacement":"<dyn ","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/spellcheck.rs","byte_start":309,"byte_end":309,"line_start":13,"line_end":13,"column_start":42,"column_end":42,"is_primary":true,"text":[{"text":"            dictionary: typos::Dictionary::new(),","highlight_start":42,"highlight_end":42}],"label":null,"suggested_replacement":">","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0782]\u001b[0m\u001b[1m: expected a type, found a trait\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/spellcheck.rs:13:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             dictionary: typos::Dictionary::new(),\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you can add the `dyn` keyword if you want a trait object\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            dictionary: \u001b[92m<dyn \u001b[0mtypos::Dictionary\u001b[92m>\u001b[0m::new(),\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[92m++++\u001b[0m                  \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `kind` on type `Identifier<'_>`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/spellcheck.rs","byte_start":539,"byte_end":543,"line_start":21,"line_end":21,"column_start":22,"column_end":26,"is_primary":true,"text":[{"text":"            if token.kind == TokenKind::Word {","highlight_start":22,"highlight_end":26}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `kind` on type `Identifier<'_>`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/spellcheck.rs:21:22\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if token.kind == TokenKind::Word {\n   \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"field `offset` of struct `Identifier` is private","code":{"code":"E0616","explanation":"Attempted to access a private field on a struct.\n\nErroneous code example:\n\n```compile_fail,E0616\nmod some_module {\n    pub struct Foo {\n        x: u32, // So `x` is private in here.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.x); // error: field `x` of struct `some_module::Foo` is private\n```\n\nIf you want to access this field, you have two options:\n\n1) Set the field public:\n\n```\nmod some_module {\n    pub struct Foo {\n        pub x: u32, // `x` is now public.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.x); // ok!\n```\n\n2) Add a getter function:\n\n```\nmod some_module {\n    pub struct Foo {\n        x: u32, // So `x` is still private in here.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n\n        // We create the getter function here:\n        pub fn get_x(&self) -> &u32 { &self.x }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.get_x()); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/spellcheck.rs","byte_start":604,"byte_end":610,"line_start":22,"line_end":22,"column_start":40,"column_end":46,"is_primary":true,"text":[{"text":"                let word = &text[token.offset..token.offset + token.len];","highlight_start":40,"highlight_end":46}],"label":"private field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a method `offset` also exists, call it with parentheses","code":null,"level":"help","spans":[{"file_name":"src/spellcheck.rs","byte_start":610,"byte_end":610,"line_start":22,"line_end":22,"column_start":46,"column_end":46,"is_primary":true,"text":[{"text":"                let word = &text[token.offset..token.offset + token.len];","highlight_start":46,"highlight_end":46}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0616]\u001b[0m\u001b[1m: field `offset` of struct `Identifier` is private\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/spellcheck.rs:22:40\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let word = &text[token.offset..token.offset + token.len];\n   \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mprivate field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: a method `offset` also exists, call it with parentheses\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                let word = &text[token.offset\u001b[92m()\u001b[0m..token.offset + token.len];\n   \u001b[1m\u001b[94m|\u001b[0m                                              \u001b[92m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"field `offset` of struct `Identifier` is private","code":{"code":"E0616","explanation":"Attempted to access a private field on a struct.\n\nErroneous code example:\n\n```compile_fail,E0616\nmod some_module {\n    pub struct Foo {\n        x: u32, // So `x` is private in here.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.x); // error: field `x` of struct `some_module::Foo` is private\n```\n\nIf you want to access this field, you have two options:\n\n1) Set the field public:\n\n```\nmod some_module {\n    pub struct Foo {\n        pub x: u32, // `x` is now public.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.x); // ok!\n```\n\n2) Add a getter function:\n\n```\nmod some_module {\n    pub struct Foo {\n        x: u32, // So `x` is still private in here.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n\n        // We create the getter function here:\n        pub fn get_x(&self) -> &u32 { &self.x }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.get_x()); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/spellcheck.rs","byte_start":618,"byte_end":624,"line_start":22,"line_end":22,"column_start":54,"column_end":60,"is_primary":true,"text":[{"text":"                let word = &text[token.offset..token.offset + token.len];","highlight_start":54,"highlight_end":60}],"label":"private field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a method `offset` also exists, call it with parentheses","code":null,"level":"help","spans":[{"file_name":"src/spellcheck.rs","byte_start":624,"byte_end":624,"line_start":22,"line_end":22,"column_start":60,"column_end":60,"is_primary":true,"text":[{"text":"                let word = &text[token.offset..token.offset + token.len];","highlight_start":60,"highlight_end":60}],"label":null,"suggested_replacement":"()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0616]\u001b[0m\u001b[1m: field `offset` of struct `Identifier` is private\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/spellcheck.rs:22:54\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let word = &text[token.offset..token.offset + token.len];\n   \u001b[1m\u001b[94m|\u001b[0m                                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mprivate field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: a method `offset` also exists, call it with parentheses\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                let word = &text[token.offset..token.offset\u001b[92m()\u001b[0m + token.len];\n   \u001b[1m\u001b[94m|\u001b[0m                                                            \u001b[92m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `len` on type `Identifier<'_>`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/spellcheck.rs","byte_start":633,"byte_end":636,"line_start":22,"line_end":22,"column_start":69,"column_end":72,"is_primary":true,"text":[{"text":"                let word = &text[token.offset..token.offset + token.len];","highlight_start":69,"highlight_end":72}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `len` on type `Identifier<'_>`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/spellcheck.rs:22:69\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let word = &text[token.offset..token.offset + token.len];\n   \u001b[1m\u001b[94m|\u001b[0m                                                                     \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `block`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/ui.rs","byte_start":15305,"byte_end":15310,"line_start":395,"line_end":395,"column_start":9,"column_end":14,"is_primary":true,"text":[{"text":"    let block = Block::default().title(\"Popup\").borders(Borders::ALL);","highlight_start":9,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/ui.rs","byte_start":15305,"byte_end":15310,"line_start":395,"line_end":395,"column_start":9,"column_end":14,"is_primary":true,"text":[{"text":"    let block = Block::default().title(\"Popup\").borders(Borders::ALL);","highlight_start":9,"highlight_end":14}],"label":null,"suggested_replacement":"_block","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `block`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/ui.rs:395:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m395\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let block = Block::default().title(\"Popup\").borders(Borders::ALL);\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_block`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 7 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 7 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0432, E0609, E0616, E0782.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0432, E0609, E0616, E0782.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0432`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0432`.\u001b[0m\n"}
